#!/usr/bin/env python3

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Crosstool wrapper for compiling DPC++ program
SYNOPSIS:
  crosstool_wrapper_driver_sycl [options passed in by cc_library()
                            or cc_binary() rule]

DESCRIPTION:
  call DPC++ compiler for device-side code, and host
  compiler for other code.
"""

from __future__ import print_function
from argparse import ArgumentParser
import os
import subprocess
import sys
import shlex
import tempfile
import shutil

# --- Environment --------------------------------------------------------------

ONEAPI_LIBRARY_PATH = os.environ['ONEAPI_LIBRARY_PATH']
ONEAPI_VERSION = os.environ['ONEAPI_VERSION']

def check_is_intel_llvm(path):
  cmd = path + " -dM -E -x c /dev/null | grep '__INTEL_LLVM_COMPILER'"
  check_result = subprocess.getoutput(cmd)
  return ('__INTEL_LLVM_COMPILER' in check_result) if check_result else False

ONEAPI_COMPILER = os.environ['ONEAPI_ICPX_PATH']
if not os.path.exists(ONEAPI_COMPILER):
  ONEAPI_COMPILER = os.environ['ONEAPI_CLANG_PATH']
  if not os.path.exists(ONEAPI_COMPILER) or check_is_intel_llvm(ONEAPI_COMPILER):
    raise RuntimeError(
      "Compiler '{0}' and '{1}' not found or invalid. CWD='{2}'".format(
        os.getenv('ONEAPI_ICPX_PATH'), os.getenv('ONEAPI_CLANG_PATH'), os.getcwd()
      )
    )

# Prefer host compilers for host steps (non-hermetic)
def _pick_host_cxx():
  for cand in ('clang++', 'c++', 'g++'):
    p = shutil.which(cand)
    if p:
      return p
  return None

def _pick_host_cc():
  for cand in ('clang', 'cc', 'gcc'):
    p = shutil.which(cand)
    if p:
      return p
  return None

HOST_CXX = _pick_host_cxx()
HOST_CC  = _pick_host_cc()

# Default CPU_COMPILER from env; override to host C++ driver when available
CPU_COMPILER = os.environ.get('GCC_PATH', '')
if HOST_CXX:
  CPU_COMPILER = HOST_CXX

# Respect AR_PATH from env; fallback to which
AR_PATH = os.environ.get('AR_PATH')
if not AR_PATH:
  found_ar = shutil.which("ar")
  if not found_ar:
    raise RuntimeError("ar not found or invalid")
  AR_PATH = found_ar

VERBOSE = os.environ.get("ONEAPI_VERBOSE", "0") == "1"

# --- Non-hermetic scrubbing ---------------------------------------------------

def _strip_next_arg(flags, i):
  """Remove flags[i] and flags[i+1] if present (for '--sysroot <arg>' style)."""
  del flags[i]
  if i < len(flags) and not flags[i].startswith('-'):
    del flags[i]
  return flags

def sanitize_nonhermetic_flags(flags):
  """
  Unconditionally remove flags that break host std headers in non-hermetic mode:
    - -nostdinc / -nostdinc++
    - --sysroot[=...] / -isysroot[=...]
  """
  f = list(flags)
  removed = []
  i = 0
  while i < len(f):
    tok = f[i]
    if tok in ('-nostdinc', '-nostdinc++'):
      removed.append(tok)
      del f[i]; continue
    if tok == '--sysroot' or tok == '-isysroot':
      removed.append(tok)
      f = _strip_next_arg(f, i); continue
    if tok.startswith('--sysroot=') or tok.startswith('-isysroot='):
      removed.append(tok)
      del f[i]; continue
    i += 1
  if VERBOSE and removed:
    print("[non-hermetic] stripped:", " ".join(removed), file=sys.stderr)
  return f

def maybe_add_gcc_toolchain(flags):
  """
  Add --gcc-toolchain=<host-root> to help Clang find GCC include{,-fixed}.
  Harmless if not needed; skipped if already present.
  """
  if any(x.startswith('--gcc-toolchain') for x in flags):
    return flags
  gcc = shutil.which('gcc')
  if not gcc:
    return flags
  res = subprocess.run([gcc, '-print-libgcc-file-name'], capture_output=True, text=True)
  if res.returncode != 0:
    return flags
  libgcc_path = res.stdout.strip()
  if not libgcc_path:
    return flags
  ver_dir = os.path.dirname(libgcc_path)            # .../<ver>
  triple_dir = os.path.dirname(ver_dir)             # .../<triple>
  libgcc_root = os.path.dirname(triple_dir)         # .../lib/gcc
  toolchain_root = os.path.dirname(libgcc_root)     # often /usr
  if not os.path.isdir(toolchain_root):
    toolchain_root = triple_dir
  return flags + ['--gcc-toolchain=' + toolchain_root]

def apply_nonhermetic(flags):
  """Always scrub (this wrapper is the non-hermetic variant) and add a GCC hint."""
  f = sanitize_nonhermetic_flags(flags)
  f = maybe_add_gcc_toolchain(f)
  return f

# --- Utilities ----------------------------------------------------------------

def system(cmd):
  """Invokes cmd with os.system() and returns the exit status."""
  if VERBOSE:
    print("[invoke]", cmd, file=sys.stderr)
  ret = os.system(cmd)
  if os.WIFEXITED(ret):
    return os.WEXITSTATUS(ret)
  else:
    return -os.WTERMSIG(ret)

def _infer_lang(args_c_list, all_flags):
  """
  Return 'c' or 'c++' for host compilation.
  Priority:
    1) explicit -x c / -x c++ if present
    2) file extension (.c => c; .cc/.cpp/.cxx => c++)
    3) fallback to c++
  """
  # Honor explicit -x first
  for i, tok in enumerate(all_flags):
    if tok == '-x' and i + 1 < len(all_flags):
      lang = all_flags[i+1].strip()
      if lang in ('c', 'c++', 'c-header', 'c++-header'):
        return 'c' if lang == 'c' or lang == 'c-header' else 'c++'
    if tok.startswith('-x'):
      lang = tok[2:].strip()
      if lang in ('c', 'c++', 'c-header', 'c++-header'):
        return 'c' if lang == 'c' or lang == 'c-header' else 'c++'

  # Infer from extension (we expect single input with -c)
  if args_c_list and len(args_c_list[0]) == 1:
    src = args_c_list[0][0]
    if src.endswith('.c'):
      return 'c'
    if src.endswith(('.cc', '.cpp', '.cxx', '.C', '.CPP')):
      return 'c++'

  # Fallback
  return 'c++'

# --- Main driver --------------------------------------------------------------

def call_compiler(argv, link=False, sycl_compile=True):
  parser = ArgumentParser()
  parser.add_argument('-c', nargs=1, action='append')
  parser.add_argument('-o', nargs=1, action='append')
  args, leftover = parser.parse_known_args(argv)

  # Base flags from Bazel/rules
  flags = leftover
  # Scrub unconditionally (non-hermetic wrapper)
  flags = apply_nonhermetic(flags)

  # SYCL & common flags
  sycl_device_only_flags = [
    '-fsycl',
    '-fno-sycl-unnamed-lambda',
    '-fsycl-targets=spir64_gen,spir64',
    '-sycl-std=2020',
    '-fhonor-infinities',
    '-fhonor-nans',
    '-fno-sycl-use-footer',
    '-Xclang -fdenormal-fp-math=preserve-sign',
    '-Xclang -cl-mad-enable',
    '-cl-fp32-correctly-rounded-divide-sqrt',
    '-fsycl-device-code-split=per_source',
    '-fsycl-unnamed-lambda',
  ]

  common_flags = [
    "-fno-finite-math-only",
    "-fno-fast-math",
    "-fexceptions",
  ]

  compile_flags = [
    '-DDNNL_GRAPH_WITH_SYCL=1',
    "-std=c++17",
  ]

  link_flags = ['-fPIC', '-lsycl', "-Wl,-no-as-needed", "-Wl,--enable-new-dtags"]
  for lib_path in ONEAPI_LIBRARY_PATH.split(":"):
    link_flags.append("-L" + lib_path)
  link_flags.append("-lOpenCL")

  sycl_link_flags = ['-fPIC', "-fsycl", '-fsycl-max-parallel-link-jobs=8', '-fsycl-link']

  in_files, out_files = [], []

  if sycl_compile:
    flags = [shlex.quote(s) for s in flags]
    # device compilation
    if args.c:
      in_files.append('-c')
      in_files.extend(args.c[0])
      assert len(args.c[0]) == 1
    if args.o:
      out_files.append('-o')
      out_files.extend(args.o[0])
      assert len(args.o[0]) == 1

    in_file = args.c[0][0]
    out_file = args.o[0][0]
    out_file_name = out_file.split('/')[-1].split('.')[0]

    # Temporary workspace
    with tempfile.TemporaryDirectory() as temp_dir:
      object_file = os.path.join(temp_dir, out_file_name + '.compile.o')
      dev_file = os.path.join(temp_dir, out_file_name + '.dev.o')

      # 1) Device + host object (compile step)
      sycl_compile_flags = [" -c {} -o {} ".format(in_file, object_file)]
      sycl_compile_flags += apply_nonhermetic(flags + common_flags + compile_flags + sycl_device_only_flags)
      compile_cmd = ONEAPI_COMPILER + ' ' + ' '.join(sycl_compile_flags)
      exit_status = system(compile_cmd)
      if exit_status != 0:
        return exit_status

      # 2) Device link step: produce device object consumable by host
      sycl_link_flags_dev = [" {} -o {} ".format(object_file, dev_file)]
      sycl_link_flags_dev += apply_nonhermetic(common_flags + sycl_link_flags)
      link_cmd = ONEAPI_COMPILER + ' ' + ' '.join(sycl_link_flags_dev)
      exit_status = system(link_cmd)
      if exit_status != 0:
        return exit_status

      # 3) Archive both into the requested output
      ar_flags = " rcsD {} {} {}".format(out_file, object_file, dev_file)
      ar_cmd = AR_PATH + ar_flags
      return system(ar_cmd)

  elif link:
    # Expand @params file if present
    expanded_flags = []
    for s in flags:
      if s.startswith("@") and os.path.isfile(s[1:]):
        with open(s[1:], "r") as f:
          expanded_flags += shlex.split(f.read())
      else:
        expanded_flags.append(s)

    # Scrub non-hermetic-unfriendly flags
    expanded_flags = apply_nonhermetic(expanded_flags)

    # Dedup while keeping "whole archive" groups together
    seen = set()
    ordered_flags = []
    for s in expanded_flags:
      if s not in seen:
        seen.add(s)
        flag_type = "whole" if s.endswith((".o", ".lo")) else "regular"
        ordered_flags.append((flag_type, shlex.quote(s)))

    deduped_flags = []
    in_whole_archive = False
    for flag_type, flag in ordered_flags:
      if flag_type == "whole":
        if not in_whole_archive:
          deduped_flags.append("-Wl,--whole-archive")
          in_whole_archive = True
        deduped_flags.append(flag)
      else:
        if in_whole_archive:
          deduped_flags.append("-Wl,--no-whole-archive")
          in_whole_archive = False
        deduped_flags.append(flag)
    if in_whole_archive:
      deduped_flags.append("-Wl,--no-whole-archive")

    # Output file
    if args.o:
      out_files.append('-o')
      out_files.extend(args.o[0])

    deduped_flags += apply_nonhermetic(common_flags + in_files + out_files + link_flags)

    # Use a response file to avoid command-line length issues
    with tempfile.NamedTemporaryFile("w", delete=False, suffix=".params") as f:
      f.write('\n'.join(deduped_flags))
      response_file = f.name

    cmd = f'{CPU_COMPILER} @{response_file}'
    return system(cmd)

  else:
    # Host compilation only
    if args.c:
      in_files.append('-c')
      in_files.extend(args.c[0])
    if args.o:
      out_files.append('-o')
      out_files.extend(args.o[0])

    # Decide C vs C++ for the TU
    lang = _infer_lang(args.c, flags)

    flags += (common_flags + in_files + out_files)
    flags = apply_nonhermetic(flags)

    # Choose the right driver: C for .c, C++ otherwise
    driver = CPU_COMPILER
    if lang == 'c' and HOST_CC:
      driver = HOST_CC

    # As a last resort, force language if the chosen driver is a C++ driver
    extra_lang = []
    base = os.path.basename(driver)
    if lang == 'c' and (base.endswith('++') or 'clang++' in base):
      extra_lang = ['-x', 'c']

    if VERBOSE:
      print(' '.join([driver] + extra_lang + flags))
    return subprocess.call([driver] + extra_lang + flags)

# --- Arg normalization & entrypoint ------------------------------------------

def standardize_key_val_args(argv, key):
  """
  Turns ["-isystem", "/path"] into ["-isystem/path"] when needed, and
  leaves ["-isystem/path"] untouched. (Matches your prior behavior.)
  """
  mod_args = []
  last = None
  for arg in argv:
    if last:
      mod_args.append(last + arg)
      last = None
      continue
    if arg == key:
      last = key
    elif arg.startswith(key):
      mod_args.append(arg.replace(' ', ''))
    else:
      mod_args.append(arg)
  return mod_args

def main():
  parser = ArgumentParser(fromfile_prefix_chars='@')
  parser.add_argument('-sycl_compile', action='store_true')
  parser.add_argument('-link_stage', action='store_true')
  args, leftover = parser.parse_known_args(sys.argv[1:])
  return call_compiler(
    standardize_key_val_args(leftover, "-isystem"),
    link=args.link_stage,
    sycl_compile=args.sycl_compile
  )

if __name__ == '__main__':
  sys.exit(main())
