#!/usr/bin/env python3

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Crosstool wrapper for compiling DPC++ program
SYNOPSIS:
  crosstool_wrapper_driver_sycl [options passed in by cc_library()
                            or cc_binary() rule]

DESCRIPTION:
  call DPC++ compiler for device-side code, and host
  compiler for other code.
"""

from __future__ import print_function
from argparse import ArgumentParser
import os
import sys
import shlex
import shutil
import subprocess
import tempfile

# ----- Env + tool discovery ---------------------------------------------------

ONEAPI_LIBRARY_PATH = os.environ.get("ONEAPI_LIBRARY_PATH", os.environ.get("LD_LIBRARY_PATH", ""))
ONEAPI_VERSION = os.environ.get("ONEAPI_VERSION", "unknown")

def _exists(p):  # small helper
    return bool(p) and os.path.exists(p)

# Prefer explicit envs; fall back to system tools
ONEAPI_COMPILER = (
    os.environ.get("ONEAPI_ICPX_PATH")
    or os.environ.get("ONEAPI_CLANG_PATH")
    or os.environ.get("CLANG_COMPILER_PATH")  # from --action_env
    or shutil.which("icpx")
    or shutil.which("clang")
)
if not _exists(ONEAPI_COMPILER):
    raise RuntimeError(
        "SYCL compiler not found. Set ONEAPI_ICPX_PATH or ONEAPI_CLANG_PATH or CLANG_COMPILER_PATH. "
        f"Current dir: {os.getcwd()}"
    )

# Host compiler used for non-sycl host compilations / links
CPU_COMPILER = os.environ.get("GCC_PATH") or os.environ.get("CLANG_COMPILER_PATH") or ONEAPI_COMPILER

# Prefer env AR_PATH; else resolve from PATH
AR_PATH = os.environ.get("AR_PATH") or shutil.which("ar")
if not _exists(AR_PATH):
    raise RuntimeError("ar not found on PATH and AR_PATH not set")

def _clang_resource_include():
    """
    Compute ['-isystem', '<resource-dir>/include'] using the real clang binary.
    Always return a two-arg list so Bazel passes them as separate args.
    """
    clang = os.environ.get("CLANG_COMPILER_PATH") or shutil.which("clang")
    if not clang:
        return []
    try:
        rd = subprocess.check_output([clang, "-print-resource-dir"], text=True).strip()
        return ["-isystem", f"{rd}/include"] if rd else []
    except Exception:
        return []

RESINC = _clang_resource_include()

# ------------------------------------------------------------------------------

def _run(cmd_argv):
    """Run a command (argv list), return its exit code."""
    try:
        return subprocess.call(cmd_argv)
    except OSError as e:
        print(f"ERROR running {cmd_argv[0]}: {e}", file=sys.stderr)
        return 1

def call_compiler(argv, link=False, sycl_compile=True):
    parser = ArgumentParser()
    parser.add_argument("-c", nargs=1, action="append")
    parser.add_argument("-o", nargs=1, action="append")
    args, leftover = parser.parse_known_args(argv)

    flags = leftover

    # ---------- Flag sets ----------
    sycl_device_only_flags = [
        "-fsycl",
        "-fno-sycl-unnamed-lambda",
        "-fsycl-targets=spir64_gen,spir64",
        "-sycl-std=2020",
        "-fhonor-infinities",
        "-fhonor-nans",
        "-fno-sycl-use-footer",
        "-Xclang", "-fdenormal-fp-math=preserve-sign",
        "-Xclang", "-cl-mad-enable",
        "-cl-fp32-correctly-rounded-divide-sqrt",
        "-fsycl-device-code-split=per_source",
        "-fsycl-unnamed-lambda",
    ]

    # https://github.com/intel/llvm/blob/sycl/clang/docs/UsersManual.rst
    common_flags = [
        "-fno-finite-math-only",
        "-fno-fast-math",
        "-fexceptions",
    ] + RESINC  # inject builtin headers for *all* compiles

    compile_flags = [
        "-DDNNL_GRAPH_WITH_SYCL=1",
        "-std=c++17",
    ]

    link_flags = [
        "-fPIC",
        "-lsycl",
        "-Wl,-no-as-needed",
        "-Wl,--enable-new-dtags",
    ] + sum([["-L" + p] for p in ONEAPI_LIBRARY_PATH.split(":") if p], []) + [
        "-lOpenCL",
    ]

    sycl_link_flags = [
        "-fPIC",
        "-fsycl",
        "-fsycl-max-parallel-link-jobs=8",
        "-fsycl-link",
    ]

    in_files, out_files = [], []
    if sycl_compile:
        # Device compilation: produce an archive with host-usable dev obj
        if args.c:
            in_files += ["-c"] + args.c[0]
        if args.o:
            out_files += ["-o"] + args.o[0]

        # Validate -c/-o
        if not args.c or not args.o or len(args.c[0]) != 1 or len(args.o[0]) != 1:
            print("icpx_wrapper: expected exactly one -c <src> and -o <out>", file=sys.stderr)
            return 1

        in_file = args.c[0][0]
        out_file = args.o[0][0]
        out_base = os.path.splitext(os.path.basename(out_file))[0]

        with tempfile.TemporaryDirectory() as tmp:
            obj_compile = os.path.join(tmp, out_base + ".compile.o")
            obj_dev = os.path.join(tmp, out_base + ".dev.o")

            # 1) compile device-enabled obj
            #    icx -fsycl -c src.cpp -o kernel.compile.o
            sycl_compile_flags = ["-c", in_file, "-o", obj_compile]
            sycl_compile_flags += flags + common_flags + compile_flags + sycl_device_only_flags
            rc = _run([ONEAPI_COMPILER] + sycl_compile_flags)
            if rc != 0:
                return rc

            # 2) produce dev obj for host linker
            #    icx -fsycl -fPIC -fsycl-link kernel.compile.o -o kernel.dev.o
            sycl_link_flags_dev = [obj_compile, "-o", obj_dev] + common_flags + sycl_link_flags
            rc = _run([ONEAPI_COMPILER] + sycl_link_flags_dev)
            if rc != 0:
                return rc

            # 3) archive the two into requested output
            #    ar rcsD output.o kernel.compile.o kernel.dev.o
            rc = _run([AR_PATH, "rcsD", out_file, obj_compile, obj_dev])
            return rc

    elif link:
        # Link stage (host link with potential device libs)
        # Expand @params files
        expanded = []
        for s in flags:
            if s.startswith("@") and os.path.isfile(s[1:]):
                with open(s[1:], "r") as f:
                    expanded += shlex.split(f.read())
            else:
                expanded.append(s)

        # Dedup; keep order; whole-archive grouping
        seen, ordered = set(), []
        for s in expanded:
            if s not in seen:
                seen.add(s)
                ftype = "whole" if s.endswith((".o", ".lo")) else "regular"
                ordered.append((ftype, s))

        deduped, in_whole = [], False
        for ftype, tok in ordered:
            if ftype == "whole":
                if not in_whole:
                    deduped.append("-Wl,--whole-archive")
                    in_whole = True
                deduped.append(tok)
            else:
                if in_whole:
                    deduped.append("-Wl,--no-whole-archive")
                    in_whole = False
                deduped.append(tok)
        if in_whole:
            deduped.append("-Wl,--no-whole-archive")

        if args.o:
            out_files += ["-o"] + args.o[0]

        final_flags = deduped + common_flags + in_files + out_files + link_flags

        # Use a response file to avoid argv length limits
        with tempfile.NamedTemporaryFile("w", delete=False, suffix=".params") as f:
            f.write("\n".join(final_flags))
            rsp = f.name

        return _run([CPU_COMPILER, f"@{rsp}"])

    else:
        # Host compilation (non-SYCL)
        if args.c:
            in_files += ["-c"] + args.c[0]
        if args.o:
            out_files += ["-o"] + args.o[0]
        final_flags = flags + common_flags + in_files + out_files

        verbose = os.environ.get("ONEAPI_VERBOSE", "0") == "1"
        if verbose:
            print(" ".join([CPU_COMPILER] + final_flags))
        return _run([CPU_COMPILER] + final_flags)

def standardize_key_val_args(argv, key):
    """
    Convert sequences like: -isystem <path>  and  '-isystem /path'
    into two clean args [-isystem, /path]; also keep '-isystem=/path' intact.
    """
    out, hold = [], None
    for a in argv:
        if hold:
            out.append(hold)
            out.append(a)
            hold = None
            continue
        if a == key:
            hold = key
        elif a.startswith(key):
            out.append(a.replace(" ", ""))  # keep -isystem=/path
        else:
            out.append(a)
    return out

def main():
    parser = ArgumentParser(fromfile_prefix_chars="@")
    parser.add_argument("-sycl_compile", action="store_true")
    parser.add_argument("-link_stage", action="store_true")
    args, leftover = parser.parse_known_args(sys.argv[1:])
    return call_compiler(standardize_key_val_args(leftover, "-isystem"),
                         link=args.link_stage, sycl_compile=args.sycl_compile)

if __name__ == "__main__":
    sys.exit(main())
